\documentclass{article}
\usepackage{listings}
\usepackage[utf8]{inputenc}


\title{Relatório Científico: Implementação do Algoritmo MD5 em Python}
\author{Ananda Guedes do Ó}
\date{December 2024}

\begin{document}

\maketitle

\section{Introdução}
O algoritmo MD5 (Message-Digest Algorithm 5) é um dos métodos de hash mais conhecidos e amplamente utilizados na verificação de integridade de dados e autenticação. Apesar de suas vulnerabilidades conhecidas, como suscetibilidade a colisões, ele ainda é relevante como ferramenta educacional para estudar conceitos fundamentais de hashing e criptografia. Este artigo apresenta a implementação do algoritmo MD5 em Python, explorando suas etapas principais e analisando os resultados obtidos. O objetivo é implementar o algoritmo MD5 de forma manual, compreender seu funcionamento e validar os resultados comparando-os com os valores gerados por bibliotecas padrões, como hashlib. Além disso, o trabalho busca demonstrar a sensibilidade do MD5 a pequenas alterações nas entradas e avaliar o desempenho da implementação.

\section{Objetivos}
Os principais objetivos deste trabalho incluem:
\begin{itemize}
    \item Desenvolver uma implementação do algoritmo MD5 em Python, respeitando todas as etapas teóricas, incluindo:
    \begin{itemize}
        \item Preenchimento (padding).
        \item Anexação do tamanho original.
        \item Divisão da mensagem em blocos de 512 bits.
        \item Processamento dos blocos com as operações de mistura.
        \item Cálculo do hash final.
    \end{itemize}
    \item Validar a implementação comparando os hashes gerados com os resultados do módulo hashlib do Python.
    \item Demonstrar a imutabilidade do hash para mensagens que diferem por apenas um bit.
    \item Avaliar o desempenho da implementação em termos de tempo de execução.
\end{itemize}

\section{Metodologia}
\subsection{Estrutura do Código}
A implementação do algoritmo MD5 foi realizada em Python e organizada em uma única classe, chamada \texttt{MD5}, que encapsula todo o processo de hash. A classe implementa todas as etapas do algoritmo, incluindo a inicialização, o preenchimento (padding), o processamento da mensagem em blocos, as operações de mistura e o cálculo do hash final.

\textbf{1. Inicialização} A primeira etapa da implementação envolve a definição de constantes essenciais para o funcionamento do MD5. Isso inclui os valores iniciais dos buffers $A$, $B$, $C$ e $D$, que são os registradores do algoritmo, bem como a tabela de constantes $K$, que são derivadas da parte fracionária da raiz cúbica de números primos. Essas constantes são usadas nas funções de mistura (as operações que alteram os valores dos registradores).

Além disso, é feita a inicialização de variáveis que irão conter os dados de entrada, os resultados intermediários e o hash final.

\textbf{2. Funções Auxiliares} 
O MD5 utiliza uma operação crucial chamada rotação cíclica de bits. Para isso, a implementação inclui uma função chamada \texttt{\_left\_rotate}
, que realiza a rotação de um número de 32 bits para a esquerda. Esta função é fundamental nas operações de mistura, pois permite o embaralhamento dos dados de forma que pequenas alterações no texto de entrada resultem em mudanças drásticas no hash final.

Aqui está o código dessa função:

\begin{lstlisting}[language=Python]
def _left_rotate(self, x, c):
     #Realiza uma rotação cíclica dos bits de x em c posições.
     #O operador "<<" realiza a rotação à esquerda e ">>" à direita,
     #combinados com a operação OR "|" para garantir a rotação circular.
    return ((x << c) | (x >> (32 - c))) & 0xFFFFFFFF
\end{lstlisting}

Este código faz uso de operações de deslocamento à esquerda (<<) e à direita (>>) para realizar a rotação circular. O operador OR ("|") é usado para combinar as partes do número que "saem" e "entram" durante a rotação, garantindo que os bits que saem por uma extremidade retornem pela outra.

\textbf{3. Preenchimento (Padding) e Divisão em Blocos} 
Antes de processar os dados, o MD5 exige que a mensagem de entrada seja ajustada para um múltiplo de 512 bits. Isso é feito através de um processo de preenchimento, que adiciona bits para garantir que o comprimento da mensagem seja adequado.

Adicionar um bit 1 (0x80): O primeiro passo do preenchimento é adicionar um bit 1 à mensagem original. 
Adicionar zeros: Em seguida, adiciona-se um número suficiente de zeros para que o comprimento da mensagem seja 64 bits a menos do que um múltiplo de 512.
Adicionar o comprimento original da mensagem: Finalmente, o comprimento original da mensagem (antes do preenchimento) é anexado aos 64 bits finais da mensagem. O comprimento é dado em bits. 
O método \texttt{update} é responsável por realizar essas transformações, e o método \texttt{\_process\_chunk} divide a mensagem em blocos de 512 bits. Cada bloco é processado individualmente através das operações de mistura.

\textbf{4. Processamento dos Blocos} 
O processamento de cada bloco de 512 bits é feito através de 64 rodadas de operações, divididas em 4 grupos de 16. Cada rodada usa uma operação não linear (como AND, OR, XOR) combinada com uma constante específica da tabela $K$ e uma função auxiliar. A operação de mistura é o principal componente que altera os valores dos registradores $A$, $B$, $C$, e $D$.

O processamento das mensagens ocorre da seguinte forma:

\begin{itemize}
    \item \textbf{Divisão da Mensagem:} Cada bloco de 512 bits é dividido em 16 palavras de 32 bits.
    \item \textbf{Execução das Operações de Mistura:} A cada rodada, um dos quatro registradores ($A$, $B$, $C$, $D$) é alterado com base nas palavras do bloco, em uma operação que envolve:
    \begin{itemize}
        \item A aplicação de uma função não linear para combinar as palavras.
        \item A rotação dos bits do registrador.
        \item A adição de constantes e valores da tabela $K$.
    \end{itemize}
\end{itemize}

\textbf{5. Cálculo do Hash Final} 
Após o processamento de todos os blocos, os valores finais de $A$, $B$, $C$ e $D$ são concatenados para formar o hash final de 128 bits. O método \texttt{digest} converte o hash em formato binário, enquanto o método \texttt{hexdigest} o converte para uma string hexadecimal legível.

O código final que gera o hash pode ser mostrado da seguinte forma:

\begin{lstlisting}[language=Python]
    def digest(self):
        # Retorna o valor do hash final, concatenando os valores de A, B, C e D
        return struct.pack('I', self.A) + struct.pack('I', self.B) + struct.pack('I', self.C) + struct.pack('I', self.D)
    
    def hexdigest(self):
        # Retorna o hash final em formato hexadecimal
        return ''.join('%02x' % b for b in self.digest())
\end{lstlisting}

\subsection{Validação}
A implementação foi validada por meio da comparação dos hashes gerados para mensagens de teste com os valores conhecidos gerados pela biblioteca hashlib do Python. Para garantir que a implementação fosse correta, as mensagens "Hello" e "Hello World" foram processadas, e os resultados obtidos com a implementação manual foram comparados com os resultados da função \texttt{md5} de hashlib.

\subsection{Sensibilidade}
Foi testada a sensibilidade do algoritmo MD5 para mensagens que diferem por apenas um bit. Isso é conhecido como a "propriedade de avalanche", que implica que mudanças pequenas na entrada resultam em grandes mudanças no hash. Como esperado, a diferença de apenas um byte entre "Hello" e "Hello\x00" produziu hashes completamente diferentes.

\subsection{Avaliação de Desempenho}
O desempenho da implementação foi avaliado medindo o tempo de execução para diferentes tamanhos de entrada (10 bytes, 1 KB e 1 MB) e comparando-o com a função \texttt{md5} da biblioteca hashlib. Como esperado, a implementação manual foi significativamente mais lenta que a versão otimizada da biblioteca.

\section{Resultados}
\subsection{Validação}
Os resultados obtidos pela implementação manual foram consistentes com os da biblioteca hashlib:

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Mensagem & Implementação Manual & hashlib & Coincidem? \\
\hline
b"Hello" & 5d41402abc4b2a76b9719d911017c592 & 5d41402abc4b2a76b9719d911017c592 & Sim \\
b"Hello World" & fc3ff98e8c6a0d3087d515c0473f8677 & fc3ff98e8c6a0d3087d515c0473f8677 & Sim \\
\hline
\end{tabular}
\end{center}

\subsection{Sensibilidade}
Hashes para mensagens que diferem por apenas um bit apresentaram diferenças drásticas:

\begin{center}
\begin{tabular}{|c|c|}
\hline
Mensagem & Hash \\
\hline
b"Hello" & 5d41402abc4b2a76b9719d911017c592 \\
b"Hello\x00" & bc6e6f16b0e76e76b70bff04ff872d5c \\
\hline
\end{tabular}
\end{center}

\subsection{Desempenho}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Tamanho da Entrada & Implementação Manual & hashlib \\
\hline
10 bytes & 0.002s & 0.0001s \\
1 KB & 0.1s & 0.0002s \\
1 MB & 10.5s & 0.02s \\
\hline
\end{tabular}
\end{center}

\section{Discussão}
A implementação manual do MD5 demonstrou-se funcional e precisa, confirmando a correta reprodução do algoritmo. Contudo, a performance foi significativamente inferior à de hashlib, destacando a otimização de baixo nível presente nas bibliotecas padrão. O trabalho também revelou a sensibilidade do MD5 a alterações mínimas nas entradas, confirmando a eficácia da propriedade de avalanche. No entanto, limitações do algoritmo, como a suscetibilidade a colisões, foram observadas e devem ser levadas em consideração em aplicações reais.

\section{Conclusão}
O desenvolvimento do algoritmo MD5 em Python proporcionou uma compreensão prática de seus fundamentos e desafios. A implementação atendeu aos objetivos propostos, sendo validada por meio de comparações com hashlib. Como trabalho futuro, sugere-se explorar a implementação de algoritmos mais modernos e seguros, como SHA-256, e analisar suas performances e propriedades em cenários comparativos.

Artefatos: O código-fonte da implementação está disponível em formato ZIP para consulta.

\end{document}
